<!DOCTYPE html>
<html lang="en">
    <head>
            <meta charset="UTF-8">
            <title>Pacman</title>
            <style>
                canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: black;
                }
            </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>
        // Definir el mapa del juego como una matriz de caracteres
        var MAP = [
        "##############################",
        "#.............##.............#",
        "#.####.######.##.######.####.#",
        "#.#  #.#    #.##.#    #.#  #.#",
        "#.####.######.##.######.####.#",
        "#............................#",
        "#.####.#.############.#.####.#",
        "#......#......##......#......#",
        "######.######.##.######.######",
        "#    #.##            ##.#    #",
        "#    #.## ####  #### ##.#    #",
        "######.## #        # ##.######",
        "#     .   #        #   .     #",
        "######.## #        # ##.######",
        "#    #.## ########## ##.#    #",
        "#    #.##            ##.#    #",
        "######.## ########## ##.######",
        "#............####............#",
        "#.####.#####.####.#####.####.#",
        "#...##.#####.####.#####.##...#",
        "###.##........  ........##.###",
        "#......##.##########.##......#",
        "#.#######....####....#######.#",
        "#.##########.####.##########.#",
        "#............................#",
        "##############################"
        ];
        
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");

        var CELL_SIZE = Math.min(canvas.width / MAP[0].length, canvas.height / MAP.length) * 3;

        // Definir los colores para los diferentes elementos del juego
        var COLOR_WALL = "#0000ff";
        var COLOR_DOT = "#ffffff";
        var COLOR_PACMAN = "#ffff00";
        var COLOR_GHOST1 = "#ff0000";
        var COLOR_GHOST2 = "#ffa500";
        var COLOR_GHOST3 = "#00ffff";
        var COLOR_GHOST4 = "#ff00ff";

        var score = 0;
        var GAME_SPEED = 150; // milisegundos por cuadro
        var pacmanDirection = "right"; // por defecto, Pac-Man se mueve hacia la derecha
        

       // Dibujar el mapa del juego
        function drawMap() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        for (var row = 0; row < MAP.length; row++) {
            for (var col = 0; col < MAP[row].length; col++) {
            var cell = MAP[row][col];
            if (cell === "#") {
                // Dibujar paredes
                ctx.fillStyle = COLOR_WALL;
                ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
            } else if (cell === ".") {
                // Dibujar puntos
                ctx.fillStyle = COLOR_DOT;
                ctx.beginPath();
                ctx.arc(col * CELL_SIZE + CELL_SIZE / 2, row * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 10, 0, 2 * Math.PI);
                ctx.fill();

                // Comprobar si Pacman ha comido el punto
                var pointX = col * CELL_SIZE + CELL_SIZE / 2;
                var pointY = row * CELL_SIZE + CELL_SIZE / 2;
                var pacmanX = pacman.x;
                var pacmanY = pacman.y;

                var dx = pointX - pacmanX;
                var dy = pointY - pacmanY;
                var distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < CELL_SIZE / 2) {
                // Pacman ha comido el punto
                score+=10;
                MAP[row] = MAP[row].substring(0, col) + " " + MAP[row].substring(col + 1);
                }

                // Mostrar la puntuación 
                ctx.fillStyle = "#ffffff";
                ctx.font = "20px Arial";
                ctx.fillText("Score: " + score, 600, 30);
            }
            }
        }
        }

        // Definir la posición y tamaño de los fantasmas
        var ghost1 = {
            x: CELL_SIZE * 14.5,
            y: CELL_SIZE * 11.5,
            radius: CELL_SIZE / 2,
        };
        var ghost2 = {
            x: CELL_SIZE * 14.5,
            y: CELL_SIZE * 13.5,
            radius: CELL_SIZE / 2,
        };
        var ghost3 = {
            x: CELL_SIZE * 12.5,
            y: CELL_SIZE * 13.5,
            radius: CELL_SIZE / 2,
        };
        var ghost4 = {
            x: CELL_SIZE * 12.5,
            y: CELL_SIZE * 11.5,
            radius: CELL_SIZE / 2,
        };

        // Dibujar los fantasmas
        function drawGhosts() {
            ctx.fillStyle = COLOR_GHOST1;
            ctx.beginPath();
            ctx.arc(ghost1.x, ghost1.y, ghost1.radius, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = COLOR_GHOST2;
            ctx.beginPath();
            ctx.arc(ghost2.x, ghost2.y, ghost2.radius, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = COLOR_GHOST3;
            ctx.beginPath();
            ctx.arc(ghost3.x, ghost3.y, ghost3.radius, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = COLOR_GHOST4;
            ctx.beginPath();
            ctx.arc(ghost4.x, ghost4.y, ghost4.radius, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();
        }

        // Definir la posición y tamaño de Pac-Man
        var pacman = {
            x: CELL_SIZE * 14.5,
            y: CELL_SIZE * 20.5,
            radius: CELL_SIZE / 2,
            angle1: 0.25 * Math.PI,
            angle2: 1.75 * Math.PI,
            direction: "right"
        };
        // Escuchar eventos de teclado para mover a Pacman
        document.addEventListener("keydown", function(event) {
        if (event.keyCode === 38) { // Flecha hacia arriba
            pacman.direction = "up";
        } else if (event.keyCode === 40) { // Flecha hacia abajo
            pacman.direction = "down";
        } else if (event.keyCode === 37) { // Flecha hacia la izquierda
            pacman.direction = "left";
        } else if (event.keyCode === 39) { // Flecha hacia la derecha
            pacman.direction = "right";
        }
        });

        // Mover a Pacman en la dirección actual
        function movePacman() {
        switch (pacman.direction) {
            case "up":
            pacman.y -= CELL_SIZE;
            break;
            case "down":
            pacman.y += CELL_SIZE;
            break;
            case "left":
            pacman.x -= CELL_SIZE;
            break;
            case "right":
            pacman.x += CELL_SIZE;
            break;
        }
        }
        // Dibujar a Pac-Man
        function drawPacman() {
        ctx.fillStyle = COLOR_PACMAN;
        ctx.beginPath();
        ctx.arc(pacman.x, pacman.y, pacman.radius, pacman.angle1, pacman.angle2);
        ctx.lineTo(pacman.x, pacman.y);
        ctx.closePath();
        ctx.fill();
        }

        // Actualizar el juego en cada cuadro
        function update() {
        movePacman();
        drawMap();
        drawGhosts();
        drawPacman();
        }

        // Ejecutar el bucle del juego
        function gameLoop() {
            // Mover a Pacman
            if (pacman.direction === "right") {
                pacman.x += CELL_SIZE / (GAME_SPEED / 10);
            } else if (pacman.direction === "left") {
                pacman.x -= CELL_SIZE / (GAME_SPEED / 10);
            } else if (pacman.direction === "up") {
                pacman.y -= CELL_SIZE / (GAME_SPEED / 10);
            } else if (pacman.direction === "down") {
                pacman.y += CELL_SIZE / (GAME_SPEED / 10);
            }

            function canMoveTo(row, col) {
            return (MAP[row][col] !== "#");
            }

            function isWall(x, y) {
            return MAP[Math.floor(y / CELL_SIZE)][Math.floor(x / CELL_SIZE)] === "#";
            }

           // Mover a Pacman
           function movePacman() {
            var nextX = pacman.x + direction.x * PACMAN_SPEED;
            var nextY = pacman.y + direction.y * PACMAN_SPEED;

            // Verificar si la siguiente celda es una pared
            var nextRow = Math.floor(nextY / CELL_SIZE);
            var nextCol = Math.floor(nextX / CELL_SIZE);
            if (MAP[nextRow][nextCol] !== "#") {
                // La siguiente celda no es una pared, actualizar la posición del personaje
                pacman.x = nextX;
                pacman.y = nextY;
            }
            }

            // Redibujar el juego
            drawGame();

            // Actualizar la posición de Pacman según la tecla presionada
            document.addEventListener("keydown", function (event) {
            if (event.key === "ArrowUp") {
                pacmanDirection.x = 0;
                pacmanDirection.y = -1;
            } else if (event.key === "ArrowDown") {
                pacmanDirection.x = 0;
                pacmanDirection.y = 1;
            } else if (event.key === "ArrowLeft") {
                pacmanDirection.x = -1;
                pacmanDirection.y = 0;
            } else if (event.key === "ArrowRight") {
                pacmanDirection.x = 1;
                pacmanDirection.y = 0;
            }
            });
            // Animar el juego
            function animate() {
            // Borrar el canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Dibujar el mapa, los puntos y las power pellets
            drawMap();

            // Dibujar a Pacman y actualizar la apertura de su boca
            function drawPacman() {
            ctx.fillStyle = COLOR_PACMAN;
            ctx.beginPath();
            ctx.arc(pacman.x + CELL_SIZE / 2, pacman.y + CELL_SIZE / 2, CELL_SIZE / 2, pacman.angle + Math.PI / 6, pacman.angle + 11 * Math.PI / 6);
            ctx.lineTo(pacman.x + CELL_SIZE / 2, pacman.y + CELL_SIZE / 2);
            ctx.fill();
            }

            // Dibujar a los fantasmas
            drawGhosts();

            // Volver a animar en el siguiente cuadro
            requestAnimationFrame(animate);
            }
            function drawDots() {
            for (var row = 0; row < MAP.length; row++) {
                for (var col = 0; col < MAP[row].length; col++) {
                if (MAP[row][col] === ".") {
                    // Dibujar puntos
                    ctx.fillStyle = COLOR_DOT;
                    ctx.beginPath();
                    ctx.arc(col * CELL_SIZE + CELL_SIZE / 2, row * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 10, 0, 2 * Math.PI);
                    ctx.fill();
                }
                }
            }
            }

            function checkCollisionWithWalls() {
                var walls = [];
                    for (var i = 0; i < MAP.length; i++) {
                    if (MAP[i].indexOf("#") !== -1) {
                        walls.push(MAP[i]);
                    }
                    }

            // Comprobar la colisión con cada pared
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];

                if (pacman.x + pacman.radius > wall.x &&
                    pacman.x - pacman.radius < wall.x + wall.width &&
                    pacman.y + pacman.radius > wall.y &&
                    pacman.y - pacman.radius < wall.y + wall.height) {
                // Si Pacman está en contacto con la pared, cambiar su dirección
                pacman.direction = oppositeDirection(pacman.direction);
                }
            }
            }

            function checkCollisions() {
            // Calcular la distancia entre el centro del pacman y el centro de cada fantasma
            var distance1 = Math.sqrt(Math.pow(pacman.x - ghost1.x, 2) + Math.pow(pacman.y - ghost1.y, 2));
            var distance2 = Math.sqrt(Math.pow(pacman.x - ghost2.x, 2) + Math.pow(pacman.y - ghost2.y, 2));
            var distance3 = Math.sqrt(Math.pow(pacman.x - ghost3.x, 2) + Math.pow(pacman.y - ghost3.y, 2));
            var distance4 = Math.sqrt(Math.pow(pacman.x - ghost4.x, 2) + Math.pow(pacman.y - ghost4.y, 2));

            // Comprobar si el pacman choca con algún fantasma
            if (distance1 < pacman.radius + ghost1.radius ||
                distance2 < pacman.radius + ghost2.radius ||
                distance3 < pacman.radius + ghost3.radius ||
                distance4 < pacman.radius + ghost4.radius) {
                // Detener el movimiento del pacman
                direction.x = 0;
                direction.y = 0;

                // Mostrar mensaje de Game Over
                alert("Game Over");

                // Reiniciar el juego
                reset();
            }
            }

            function gameLoop() {
            updatePacman();
            // Actualizar la posición de Pacman
            updatePacmanPosition();

            // Comprobar la colisión con las paredes
            checkCollisionWithWalls();


            // Dibujar el juego
            drawMap();
            drawPacman();
            drawGhosts();

            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);
    }
        </script>
    </body>
</html>